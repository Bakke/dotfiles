#!/bin/bash

# [[ -f "/usr/share/zsh/plugins/zsh-autocomplete/zsh-autocomplete.plugin.zsh" ]] && source "/usr/share/zsh/plugins/zsh-autocomplete/zsh-autocomplete.plugin.zsh"

# Use modern completion system
autoload -Uz compinit
compinit

if [[ $(command -v kubectl) ]]; then
    source <(kubectl completion zsh)
fi

zstyle ':completion:*' menu select
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'

# Make zsh know about hosts already accessed by SSH
zstyle -e ':completion:*:(ssh|scp|sftp|rsh|rsync):hosts' hosts 'reply=(${=${${(f)"$(cat {/etc/ssh_,~/.ssh/known_}hosts(|2)(N) /dev/null)"}%%[# ]*}//,/ })'

if whence dircolors >/dev/null; then
    eval "$(dircolors -b)"
    zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
    alias ls='ls --color'
else
    export CLICOLOR=1
    zstyle ':completion:*:default' list-colors ''
fi

# artisan completion
_artisan() {

	if [ -f artisan ]; then
		compadd $( php artisan --no-ansi | sed "1,/Available commands/d" | awk '/^ +[a-z]+/ { print $1 }' )
	fi

}
compdef _artisan php artisan
compdef _artisan artisan

# Composer basic command completion
_composer_get_command_list () {
	$_comp_command1 --no-ansi 2>/dev/null | sed "1,/Available commands/d" | awk '/^[ \t]*[a-z]+/ { print $1 }'
}

_composer_get_required_list () {
	$_comp_command1 show -s --no-ansi 2>/dev/null | sed '1,/requires/d' | awk 'NF > 0 && !/^requires \(dev\)/{ print $1 }'
}

_composer () {
	local curcontext="$curcontext" state line
	typeset -A opt_args
	_arguments \
		'1: :->command'\
		'*: :->args'

	case $state in
		command)
		compadd $(_composer_get_command_list)
		;;
	*)
		compadd $(_composer_get_required_list)
		;;
	esac
}

compdef _composer composer
compdef _composer composer.phar

_fzf_complete_kubectl() {
    ARGS="$@"

    local resourceList

    if [[ $ARGS =~ 'exec' ]]; then
        resourceList=$(kubectl get pods -A | grep '^[[:lower:]]')

        _fzf_complete -- "$@" < <(
            echo ${resourceList}
        )
    elif [[ $ARGS =~ 'logs|describe|edit|delete' ]]; then
        resourceList=$(kubectl get all -A | grep '^[[:lower:]]')

        _fzf_complete -- "$@" < <(
            echo ${resourceList}
        )
    elif [[ $ARGS =~ ' -n' ]]; then
        resourceList=$(kubectl get namespaces -A | grep '^[[:lower:]]')

        _fzf_complete -- "$@" < <(
            echo ${resourceList}
        )
    else
        eval "zle ${fzf_default_completion:-expand-or-complete}"
    fi
}

_fzf_complete_kubectl_post() {
    local original resource namespace

    original=$(awk '{print $0}')
    namespace=$(echo ${original} | awk '{print $1}')
    resource=$(echo ${original} | awk '{print $2}')

    if [[ $ARGS =~ 'exec' ]]; then
        if [ -n "$resource" ] && [ -n "$namespace" ]; then
            echo "-it ${resource} -n ${namespace} --"
        elif [ -n "$resource" ]; then
            echo "-it ${resource} --"
        fi
    elif [[ $ARGS =~ 'logs|describe|edit|delete' ]]; then
        if [ -n "$resource" ] && [ -n "$namespace" ]; then
            echo "${resource} -n ${namespace}"
        elif [ -n "$resource" ]; then
            echo "${resource}"
        fi
    elif [[ $ARGS =~ ' -n' ]]; then
        echo ${namespace}
    fi
}

_fzf_complete_k() { _fzf_complete_kubectl "$@" }
_fzf_complete_k_post() { _fzf_complete_kubectl_post "$@" }

_cheat() {
    compadd $(cheat -l | awk '{print $1}')
}
compdef _cheat cheat

_ki() {
    compadd $(kubectl api-resources --verbs=list -o name)
}
compdef _ki ki

_fzf_complete_cheat() {
    ARGS="$@"

    local commandList
    commandList=$(cheat -l | awk '{print $1}')

    _fzf_complete -- "$@" < <(
        echo ${commandList}
    )
}

_fzf_complete_tmux() {
    ARGS="$@"

    local commandList
    commandList=$(tmux ls -F '#{session_name}')

    _fzf_complete -- "$@" < <(
        echo ${commandList}
    )
}

_fzf_complete_git() {
    ARGS="$@"

    local commitList
    local branchList

    if [[ $ARGS == "git rebase"* ]]; then
        commitList=$(git log --oneline --no-decorate --no-merges)

        _fzf_complete -- "$@" < <(
            echo ${commitList}
        )
    elif [[ $ARGS == "git branch"* || $ARGS == "git checkout"* ]]; then
        branchList=$(git branch --format='%(refname:short)')

        _fzf_complete -- "$@" < <(
            echo ${branchList}
        )
    elif [[ $ARGS == "git show"* ]]; then
        commitList=$(git log --oneline)

        _fzf_complete -- "$@" < <(
            echo ${commitList}
        )
    else
        eval "zle ${fzf_default_completion:-expand-or-complete}"
    fi
}

_fzf_complete_git_post() {
    awk '{print $1}'
}

_fzf_complete_gb() {
    local branchList
    branchList=$(git branch --format='%(refname:short)')

    _fzf_complete -- "$@" < <(
        echo ${branchList}
    )
}
_fzf_complete_gbd() { _fzf_complete_gb "$@" }
_fzf_complete_gco() { _fzf_complete_gb "$@" }
